\documentclass[a4paper,12pt]{article}
\usepackage{hyperref}
\usepackage{float}
\usepackage{graphicx}
\usepackage{caption}
\begin{document}
\title{Reducing iptables configuration complexity using chains}
\author{Dieter Adriaenssens\\
Ghent University, Belgium}
\date{LinuxTag - Berlin\\
May 8th, 2014}
\maketitle

\pagebreak
\section{Abstract}

The goal is to show how to reduce complexity of an iptables configuration, by adding structure to it using chains and as a result making it more maintainable, and faster.

Iptables is the most used local firewall configuring system on linux systems. It is basically a tool for creating the rulesets for netfilter, a packet filtering framework which was introduced in the linux 2.4 kernel. After first explaining the basics about how iptables/netfilter works (rules, targets, the different filters you can set), we get on to the concept of chains, mentioning the default chains (INPUT, OUTPUT, FORWARD) and that custom chains can be created.

Then by using some examples, it is explained how to define different rules to filter traffic and how this can quickly become complex and hard to maintain. By grouping rules with similar parameters (fe. the same protocol and/or port), the rule could filter on the similar part and then target a custom chain, where a set of rules is created that only filter the specific information (like an IP address). The targetted chains can even be combined or reused for several rules. But when doing so one should be beware of the way netfilter behaves when the end of a chain is reached.

The result is a set of rules that looks less complex, because you get a better structured set of rules that point to different chains (with appropriately chosen names). It is more maintainable, because adding a new rule (fe. a new IP address that is allowed to connect to TCP port 22), means just adding a rule that filters on that IP address to the right chain. And it runs faster because only a subset of the filter rules has to be checked.

The testcase used for the examples will be a server setup with some basic services and ports (http(s), ssh, smb and a webbased management tool) and different groups of IP-addresses/ranges that can access those services (general public, sysadmins, webmasters). In the example, several chains will be reused and combined to connect the different chains to the different protocols. Fe. the sysadmins should have access to ssh, smb and the webbased management tool, while the webmasters only need smb.

The audience should have a basic understanding of network concepts like protocols, ports, IP-addresses and packets.

\pagebreak
\tableofcontents

\section{Introduction}
Setting up a firewall on your *nix box, being it a workstation, laptop, or server, is always a good idea. In most cases, you can do with some simple firewall rules, f.e. on your laptop, block all incoming requests (except the established connections, i.e. the replies on the outgoing requests you made), or on a simple webserver (allow port 80 only).\\

But if you need more complex rules, f.e. a server that hosts a website available for the entire internet, but with an ssh and samba service that should only be available for the local subnet, or even some specific IP addresses, it becomes a bit more complex.\\
And if you want to filter the outgoing traffic as well, your iptables rules get a mess after a while, and when you want to change anything, chances of a mistake or forgetting something are high, which may result in locking yourself out of your box (at least for remote access), or leaving something open that shouldn't.\\

To make your rules more manageable, you can make use of chains in your iptables rules. This paper is inspired by an article that uses chains to make iptables more efficient (faster). The goal of this paper is to get iptables rules that are easier to read and configure, but it will result in faster handling of packets as well.\\

\section{Brief introduction to iptables}
\subsection{ESTABLISHED state}
When using this option, you can filter for established connections. If you define it in both the INPUT and OUTPUT rules, you only have to define in the INPUT rules which NEW incoming requests should be allowed, and in the OUTPUT rules which NEW outgoing request are allowed. The established connections will be allowed and should not be redefined (making the configuration a lot more readable and maintainable). An example allowing only an ssh service without using the ESTABLISHED state would be :
\begin{verbatim}
  iptables -A INPUT -p tcp --dport ssh -j ACCEPT
  iptables -A INPUT -j REJECT
  iptables -A OUTPUT -p tcp --sport ssh -j ACCEPT
  iptables -A OUTPUT -j REJECT
\end{verbatim}

Basically, every incoming/outgoing connection is dropped, except if the incoming packet has port 22 (ssh) as destination, or if the outgoing packet was sent from port 22 (which is the reply of the ssh server).\\

When using ESTABLISHED state, this will become :
\begin{verbatim}
  iptables -A INPUT -p tcp --dport ssh -j ACCEPT
  iptables -A INPUT -j REJECT
  iptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT
  iptables -A OUTPUT -j REJECT
\end{verbatim}

Now, every incoming/outgoing connection is dropped, except if the incoming packet has port 22 (ssh) as destination, or if the packet belongs to an established connection. Because incoming connections to port 22 are allowed, the firewall will remember a packet coming in, creating a 'connection' for the host/port the packet originates from when the ssh server replies to it. So when the reply of the ssh server is sent out, it matches an 'established' connection and will be allowed out.\\

In this example, the benefit of using the connection state is not clear, but when more allowed incoming services are added, they only have to be added on the INPUT chain, but not on the OUTPUT chain, because they are covered by the ESTABLISHED rule.\\
In the first example (without the ESTABLISHED rule), every allowed incoming connection should be repeated in the OUTPUT chain, matching the packets sent for the outgoing connection, which results in an equal amount of rules on both chains.\\
If you want to do filtering in both directions (allowing incoming request for listening services and outgoing request for remote services), this can become very messy, and almost unmaintainable without making mistakes.\\

\subsection{Introducing chains}
When two services (on different ports) should be available to a limited but identical list of IP addresses.
Without using chains, for every combination of port and IP a rule should be created :
\begin{verbatim}
  iptables -A INPUT -p tcp -m tcp -s 10.100.2.3 --dport 22 -j ACCEPT
  iptables -A INPUT -p tcp -m tcp -s 10.100.2.4 --dport 22 -j ACCEPT
  iptables -A INPUT -p tcp -m tcp -s 10.100.2.7 --dport 22 -j ACCEPT

  iptables -A INPUT -p tcp -m tcp -s 10.100.2.3 --dport 10000 -j ACCEPT
  iptables -A INPUT -p tcp -m tcp -s 10.100.2.4 --dport 10000 -j ACCEPT
  iptables -A INPUT -p tcp -m tcp -s 10.100.2.7 --dport 10000 -j ACCEPT
\end{verbatim}

Resulting in a lot of rules, and when an IP address has to be changed, added or removed, this has to be done for every corresponding rule.\\

When using chains, this can be much easier. Imagine, that you first check if the packet matches the destination port, and if it does, jump to a new chain, where a list of IP addresses is checked. :
\begin{verbatim}
  // create new chain admin_IP
  iptables -N admin_IP

  // add rules to chain admin_IP
  iptables -A admin_IP -s 10.100.2.3 -j ACCEPT
  iptables -A admin_IP -s 10.100.2.4 -j ACCEPT
  iptables -A admin_IP -s 10.100.2.7 -j ACCEPT
  // drop all packets that are not matched by previous rules
  iptables -A admin_IP -j DROP

  // filter ports in INPUT chain
  iptables -A INPUT -p tcp -m tcp --dport 22 -j admin_IP
  iptables -A INPUT -p tcp -m tcp --dport 10000 -j admin_IP
\end{verbatim}

As you can see, there is are several benefits of putting the IP addresses in a separate chain :
\begin{itemize}
    \item the list of IP addresses in the separate chain can be reused for both ports, so they have to be defined only once.
    \item adding/changing/removing an IP address is much easier
    \item there is a better overview of the firewall rules
\end{itemize}

\section{Optimizing configuration with an example setup}
\section{Conclusion}

\end{document}
